<!DOCTYPE html>
<!-- DO NOT EDIT! This test has been generated by /html/canvas/tools/gentest.py. -->
<title>Canvas test: 2d.text.measure.selection-rects.tentative</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/html/canvas/resources/canvas-tests.js"></script>
<link rel="stylesheet" href="/html/canvas/resources/canvas-tests.css">

<h1>2d.text.measure.selection-rects.tentative</h1>

<script>

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'ltr';
    el.style.textAlign = 'left';
    el.style.letterSpacing = '0px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'ltr';
  ctx.textAlign = 'left';
  ctx.letterSpacing = '0px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction ltr, text align left, and 0px letter spacing.");

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'rtr';
    el.style.textAlign = 'left';
    el.style.letterSpacing = '0px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'rtr';
  ctx.textAlign = 'left';
  ctx.letterSpacing = '0px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction rtr, text align left, and 0px letter spacing.");

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'ltr';
    el.style.textAlign = 'center';
    el.style.letterSpacing = '0px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'ltr';
  ctx.textAlign = 'center';
  ctx.letterSpacing = '0px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction ltr, text align center, and 0px letter spacing.");

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'rtr';
    el.style.textAlign = 'center';
    el.style.letterSpacing = '0px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'rtr';
  ctx.textAlign = 'center';
  ctx.letterSpacing = '0px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction rtr, text align center, and 0px letter spacing.");

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'ltr';
    el.style.textAlign = 'right';
    el.style.letterSpacing = '0px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'ltr';
  ctx.textAlign = 'right';
  ctx.letterSpacing = '0px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction ltr, text align right, and 0px letter spacing.");

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'rtr';
    el.style.textAlign = 'right';
    el.style.letterSpacing = '0px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'rtr';
  ctx.textAlign = 'right';
  ctx.letterSpacing = '0px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction rtr, text align right, and 0px letter spacing.");

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'ltr';
    el.style.textAlign = 'left';
    el.style.letterSpacing = '10px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'ltr';
  ctx.textAlign = 'left';
  ctx.letterSpacing = '10px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction ltr, text align left, and 10px letter spacing.");

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'rtr';
    el.style.textAlign = 'left';
    el.style.letterSpacing = '10px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'rtr';
  ctx.textAlign = 'left';
  ctx.letterSpacing = '10px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction rtr, text align left, and 10px letter spacing.");

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'ltr';
    el.style.textAlign = 'center';
    el.style.letterSpacing = '10px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'ltr';
  ctx.textAlign = 'center';
  ctx.letterSpacing = '10px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction ltr, text align center, and 10px letter spacing.");

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'rtr';
    el.style.textAlign = 'center';
    el.style.letterSpacing = '10px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'rtr';
  ctx.textAlign = 'center';
  ctx.letterSpacing = '10px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction rtr, text align center, and 10px letter spacing.");

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'ltr';
    el.style.textAlign = 'right';
    el.style.letterSpacing = '10px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'ltr';
  ctx.textAlign = 'right';
  ctx.letterSpacing = '10px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction ltr, text align right, and 10px letter spacing.");

test(t => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  function placeAndSelectTextInDOM(text, from, to) {
    const el = document.createElement("div");
    el.innerHTML = text;
    el.style.font = '50px sans-serif';
    el.style.direction = 'rtr';
    el.style.textAlign = 'right';
    el.style.letterSpacing = '10px';
    document.body.appendChild(el);

    let range = document.createRange();

    range.setStart(el.childNodes[0], 0);
    range.setEnd(el.childNodes[0], text.length);
    const parent = range.getClientRects()[0];

    range.setStart(el.childNodes[0], from);
    range.setEnd(el.childNodes[0], to);

    let sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    let sel_rects = sel.getRangeAt(0).getClientRects();

    document.body.removeChild(el);

    // Offset to the alignment point determined by textAlign.
    let text_align_dx;
    switch (el.style.textAlign) {
      case 'right':
        text_align_dx = parent.width;
        break;
      case 'center':
        text_align_dx = parent.width / 2;
        break;
      default:
        text_align_dx = 0;
    }

    for(let i = 0 ; i < sel_rects.length ; ++i) {
      sel_rects[i].x -= parent.x + text_align_dx;
      sel_rects[i].y -= parent.y;
    }

    return sel_rects;
  }

  function checkRectListsMatch(list_a, list_b) {
    _assertSame(list_a.length, list_b.length, "list_a.length", "list_b.length");
    for(let i = 0 ; i < list_a.length ; ++i) {
      assert_approx_equals(list_a[i].x, list_b[i].x, 1.0);
      assert_approx_equals(list_a[i].width, list_b[i].width, 1.0);
      assert_approx_equals(list_a[i].height, list_b[i].height, 1.0);
      // Y-position not tested here as getting the baseline for text in the
      // DOM is not straightforward.
    }
  }

  ctx.font = '50px sans-serif';
  ctx.direction = 'rtr';
  ctx.textAlign = 'right';
  ctx.letterSpacing = '10px';

  const kTexts = [
    'UNAVAILABLE',
    'ðŸðŸŽ¶ðŸ',
    'ï¼‰ï¼ˆã‚ï¼‰ï¼ˆ'
  ]

  for (const text of kTexts) {
    const tm = ctx.measureText(text);
    // First character.
    checkRectListsMatch(
      tm.getSelectionRects(0, 1),
      placeAndSelectTextInDOM(text, 0, 1)
    );
    // Last character.
    checkRectListsMatch(
      tm.getSelectionRects(text.length - 1, text.length),
      placeAndSelectTextInDOM(text, text.length - 1, text.length)
    );
    // Whole string.
    checkRectListsMatch(
      tm.getSelectionRects(0, text.length),
      placeAndSelectTextInDOM(text, 0, text.length)
    );
    // Intermediate string.
    checkRectListsMatch(
      tm.getSelectionRects(1, text.length - 1),
      placeAndSelectTextInDOM(text, 1, text.length - 1)
    );
    // Invalid start > end string. Creates 0 width rectangle.
    checkRectListsMatch(
      tm.getSelectionRects(3, 2),
      placeAndSelectTextInDOM(text, 3, 2)
    );
    checkRectListsMatch(
      tm.getSelectionRects(1, 0),
      placeAndSelectTextInDOM(text, 1, 0)
    );
  }
}, "Check that TextMetrics::getSelectionRects() matches its DOM equivalent, with direction rtr, text align right, and 10px letter spacing.");

</script>
</div>
